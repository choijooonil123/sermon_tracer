<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>설교문 구조 분석 및 음성 인식</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 180px; }
    .highlight { background: yellow; font-weight: bold; }
    .block { margin-left: 0; }
    .indent1 { margin-left: 20px; }
    .indent2 { margin-left: 40px; }
    .tree { margin-top: 1em; background: #f5f5f5; padding: 10px; border: 1px solid #ddd; }
    .context { margin-top: 1em; background: #eef; padding: 10px; border: 1px solid #88c; }
    #speechOutput { color: green; font-weight: bold; margin-top: 10px; }
  </style>
</head>
<body>

<h1>설교문 구조 분석 & 음성 인식 하이라이트 002</h1>

<textarea id="sermonInput" placeholder="설교문을 붙여넣으세요..."></textarea>

<h2>① 설교문 구조</h2>
<div id="structureTree" class="tree"></div>

<h2>② 전체 설교문</h2>
<div id="sermonDisplay"></div>

<p><button onclick="startContinuousRecognition()">🎤 설교 감지 시작</button></p>
<p id="speechOutput"></p>
  
<h2>③ 현재 설교 문맥</h2>
<div id="context" class="context"></div>

<script>
  let sermonLines = [];
  let currentIdx = 0;
  let isListening = false;

  document.getElementById("sermonInput").addEventListener("input", analyzeSermon);

  function analyzeSermon() {
    const input = document.getElementById("sermonInput").value;
    const lines = input.split(/\n/).filter(l => l.trim() !== "");

    sermonLines = lines.map((line, idx) => {
      let indent = "block";
      if (/^\d+\.\s/.test(line)) indent = "block";
      else if (/^\d+\)\s/.test(line)) indent = "indent1";
      else if (/^\(\d+\)\s/.test(line)) indent = "indent2";
      return { idx, text: line.trim(), indent };
    });

    currentIdx = 0;
    renderStructureTree();
    renderSermon();
  }

  function renderStructureTree() {
    const container = document.getElementById("structureTree");
    container.innerHTML = "";

    const seen = { block: new Set(), indent1: new Set(), indent2: new Set() };

    sermonLines.forEach(line => {
      const { text, indent } = line;
      let match = "";
      if (indent === "block") match = text.match(/^\d+\.\s(.*)/);
      else if (indent === "indent1") match = text.match(/^\d+\)\s(.*)/);
      else if (indent === "indent2") match = text.match(/^\(\d+\)\s(.*)/);

      if (match && !seen[indent].has(match[1])) {
        const div = document.createElement("div");
        div.className = indent;
        div.textContent = match[1];
        container.appendChild(div);
        seen[indent].add(match[1]);
      }
    });
  }

  function renderSermon(highlightIdx = -1) {
    const container = document.getElementById("sermonDisplay");
    container.innerHTML = "";

    sermonLines.forEach((line, idx) => {
      const div = document.createElement("div");
      div.className = line.indent;

      if (idx === highlightIdx) {
        div.classList.add("highlight");
        div.style.fontSize = "1.5em";
      }

      div.textContent = line.text;
      container.appendChild(div);
    });

    const context = document.getElementById("context");
    if (highlightIdx >= 0) {
      const before = sermonLines.slice(Math.max(0, highlightIdx - 4), highlightIdx).map(l => l.text).join("\n");
      const current = sermonLines[highlightIdx].text;
      const after = sermonLines.slice(highlightIdx + 1, highlightIdx + 5).map(l => l.text).join("\n");

      context.innerHTML = `<pre>${before}\n<span class="highlight" style="font-size:1.5em;">${current}</span>\n${after}</pre>`;
    } else {
      context.innerHTML = "";
    }
  }

  function startContinuousRecognition() {
    if (isListening) return;
    isListening = true;
    recognizeUntilMatchLoop();
  }

  function recognizeUntilMatchLoop() {
    if (!isListening) return;

    const recognition = new webkitSpeechRecognition();
    recognition.lang = "ko-KR";
    recognition.continuous = false; // 끊길 때 종료
    recognition.interimResults = false;

    recognition.onresult = function (event) {
      const speechText = event.results[0][0].transcript.trim();
      document.getElementById("speechOutput").textContent = `🎙 인식된 음성: ${speechText}`;
      const matched = processMatching(speechText);
      if (!matched) {
        setTimeout(() => recognizeUntilMatchLoop(), 500); // 다시 인식
      }
    };

    recognition.onerror = function (event) {
      console.warn("음성 인식 오류:", event.error);
      setTimeout(() => recognizeUntilMatchLoop(), 1000); // 오류 후 재시도
    };

    recognition.onend = function () {
      if (isListening) {
        setTimeout(() => recognizeUntilMatchLoop(), 500); // 자동 종료되면 재시작
      }
    };

    recognition.start();
  }

  function processMatching(speech) {
    let bestMatchIdx = -1;
    let maxScore = 0;
    const searchRange = 10;
    const startIdx = currentIdx;
    const endIdx = Math.min(sermonLines.length, currentIdx + searchRange);

    for (let idx = startIdx; idx < endIdx; idx++) {
      const line = sermonLines[idx];
      const clean = line.text.replace(/[\[\]]/g, '');
      const score = fuzzySimilarity(speech, clean);

      if (score > maxScore) {
        maxScore = score;
        bestMatchIdx = idx;
      }

      if (score >= 0.9) {
        currentIdx = idx + 1;
        renderSermon(idx);
        checkNextSentenceAuto();
        return true;
      }
    }

    if (maxScore > 0.5) {
      currentIdx = bestMatchIdx + 1;
      renderSermon(bestMatchIdx);
      checkNextSentenceAuto();
      return true;
    }

    return false;
  }

  function checkNextSentenceAuto() {
    const idx = currentIdx;
    if (idx >= sermonLines.length) return;

    const nextLine = sermonLines[idx];
    const speechText = nextLine.text.replace(/[\[\]]/g, '');
    const score = fuzzySimilarity(speechText, speechText); // 완전 일치

    if (score >= 0.9) {
      currentIdx = idx + 1;
      renderSermon(idx);
      setTimeout(() => checkNextSentenceAuto(), 300); // 다음 줄도 이어서 자동 확인
    }
  }

  function fuzzySimilarity(a, b) {
    const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
    const maxLen = Math.max(a.length, b.length);
    return maxLen === 0 ? 1 : (1 - distance / maxLen);
  }

  function levenshteinDistance(a, b) {
    const matrix = Array.from({ length: a.length + 1 }, () =>
      Array(b.length + 1).fill(0)
    );

    for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
    for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

    for (let i = 1; i <= a.length; i++) {
      for (let j = 1; j <= b.length; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }

    return matrix[a.length][b.length];
  }
</script>
</body>
</html>
