<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì„¤êµì¶”ì ì‹œìŠ¤í…œ 001</title>
  <style>
    body { font-family: Arial; margin: 40px; background: #f9f9f9; }
    textarea { width: 100%; height: 150px; font-size: 1em; padding: 10px; white-space: pre-wrap; }
    select, button { margin: 5px; padding: 10px; font-size: 1em; }
    #previewBox {
      background: #fff; border: 1px solid #ccc; padding: 20px; margin-bottom: 15px;
      min-height: 100px; line-height: 1.6; white-space: pre-wrap;
    }
    .unitBox { margin: 10px 0; padding: 10px; border-left: 6px solid #ddd; cursor: pointer; }
    .unitBox.level1 { border-color: #3498db; background: #ecf6fc; }
    .unitBox.level2 { border-color: #2ecc71; background: #eafaf1; margin-left: 20px; }
    .unitBox.level3 { border-color: #f39c12; background: #fef6e4; margin-left: 40px; }
    .unitBox.selected { border-width: 6px; font-weight: bold; background: #fff3cd !important; }
    .highlight { background: #ffd54f; font-weight: bold; }
    #status { font-weight: bold; color: #e74c3c; margin-bottom: 15px; }
  </style>
</head>
<body>

<h1>ğŸ“Œ ì„¤êµì¶”ì ì‹œìŠ¤í…œ</h1>

<div id="status">ğŸ™ï¸ ìŒì„± ì¸ì‹ ëŒ€ê¸° ì¤‘...</div>
<button onclick="startRecognition()">ğŸ™ï¸ ìŒì„± ì¸ì‹ ì‹œì‘</button>

<p>ì˜ë¯¸ ë‹¨ìœ„ë¥¼ ê³„ì¸µì ìœ¼ë¡œ êµ¬ë¶„í•´ ì£¼ì„¸ìš”:</p>
<ul>
  <li><code>{í°ë‹¨ìœ„}</code></li>
  <li><code>{{ì¤‘ê°„ë‹¨ìœ„}}</code></li>
  <li><code>{{{ì‘ì€ë‹¨ìœ„}}}</code></li>
</ul>

<textarea id="sermonInput" placeholder="ì˜ˆ: {ì„œë¡ ì…ë‹ˆë‹¤} {{ë¯¿ìŒì´ë€}} {{{ë¯¿ìŒì€ ë°”ë¼ëŠ” ê²ƒë“¤ì˜ ì‹¤ìƒì´ìš”}}}"></textarea>
<div id="previewBox"></div>

<script>
let selectedIndex = -1;
let currentUnits = [];
let recognition;

function parseSermon(text) {
  const units = [];
  const regex = /\{\{\{(.*?)\}\}\}|\{\{(.*?)\}\}|\{(.*?)\}/gs;
  let match;
  while ((match = regex.exec(text)) !== null) {
    if (match[1]) units.push({ level: 3, content: match[1].trim() });
    else if (match[2]) units.push({ level: 2, content: match[2].trim() });
    else if (match[3]) units.push({ level: 1, content: match[3].trim() });
  }
  return units;
}

function renderPreview(units) {
  const preview = document.getElementById("previewBox");
  preview.innerHTML = units.map((u, i) => {
    const selected = i === selectedIndex ? 'selected' : '';
    return `<div class="unitBox level${u.level} ${selected}" data-index="${i}" id="unit-${i}">${u.content}</div>`;
  }).join("\n");
}

document.getElementById("sermonInput").addEventListener("input", () => {
  const text = document.getElementById("sermonInput").value;
  currentUnits = parseSermon(text);
  renderPreview(currentUnits);
});

document.getElementById("previewBox").addEventListener("click", e => {
  const box = e.target.closest('.unitBox');
  if (box) {
    selectedIndex = parseInt(box.dataset.index);
    renderPreview(currentUnits);
  }
});

function startRecognition() {
  if (!('webkitSpeechRecognition' in window)) {
    alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    return;
  }

  document.getElementById("status").innerText = "ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘...";

  recognition = new webkitSpeechRecognition();
  recognition.lang = 'ko-KR';
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    const transcript = Array.from(event.results)
      .map(result => result[0].transcript)
      .join('');

    if (selectedIndex >= 0) {
      const currentText = currentUnits[selectedIndex].content;
      const sentences = currentText.split(/(?<=[.!?\n])/);
      const highlighted = sentences.map(s => {
        return transcript.includes(s.trim()) ? `<span class='highlight'>${s}</span>` : s;
      }).join('');
      document.getElementById("unit-" + selectedIndex).innerHTML = highlighted;
    }
  };

  recognition.start();
}
</script>

</body>
</html>
