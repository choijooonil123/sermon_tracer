<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>설교문 분석 및 음성 인식 001</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 180px; }
    .highlight { background: yellow; font-weight: bold; }
    .block { margin-left: 0; }
    .indent1 { margin-left: 20px; }
    .indent2 { margin-left: 40px; }
    .tree { margin-top: 1em; background: #f5f5f5; padding: 10px; border: 1px solid #ddd; }
    .context { margin-top: 1em; background: #eef; padding: 10px; border: 1px solid #88c; }
    #speechOutput { color: green; font-weight: bold; margin-top: 10px; }
  </style>
</head>
<body>

<h1>설교문 구조 분석 & 음성 인식 하이라이트</h1>

<textarea id="sermonInput" placeholder="설교문을 붙여넣으세요..."></textarea>
<h2>① 설교문 구조</h2>
<div id="structureTree" class="tree"></div>
  
<p><button onclick="startRecognition()">🎤 4초 음성 인식</button></p>
<p id="speechOutput"></p>

<h2>③ 현재 설교 문맥</h2>
<div id="context" class="context"></div>

<script>
  let sermonLines = [];

  document.getElementById("sermonInput").addEventListener("input", analyzeSermon);

  function analyzeSermon() {
    const input = document.getElementById("sermonInput").value;
    const lines = input.split(/\n/).filter(l => l.trim() !== "");

    sermonLines = lines.map((line, idx) => {
      let indent = "block";
      if (/^\d+\.\s/.test(line)) indent = "block";
      else if (/^\d+\)\s/.test(line)) indent = "indent1";
      else if (/^\(\d+\)\s/.test(line)) indent = "indent2";
      return { idx, text: line.trim(), indent };
    });

    renderStructureTree();
    renderSermon();
  }

  function renderStructureTree() {
    const container = document.getElementById("structureTree");
    container.innerHTML = "";

    const seen = { block: new Set(), indent1: new Set(), indent2: new Set() };

    sermonLines.forEach(line => {
      const { text, indent } = line;
      let match = "";
      if (indent === "block") match = text.match(/^\d+\.\s(.*)/);
      else if (indent === "indent1") match = text.match(/^\d+\)\s(.*)/);
      else if (indent === "indent2") match = text.match(/^\(\d+\)\s(.*)/);

      if (match && !seen[indent].has(match[1])) {
        const div = document.createElement("div");
        div.className = indent;
        div.textContent = match[1];
        container.appendChild(div);
        seen[indent].add(match[1]);
      }
    });
  }

  function renderSermon(highlightIdx = -1) {
    const container = document.getElementById("sermonDisplay");
    container.innerHTML = "";
    sermonLines.forEach((line, idx) => {
      const div = document.createElement("div");
      div.className = line.indent + (idx === highlightIdx ? " highlight" : "");
      div.textContent = line.text;
      container.appendChild(div);
    });

    const context = document.getElementById("context");
    if (highlightIdx >= 0) {
      const before = sermonLines.slice(Math.max(0, highlightIdx - 3), highlightIdx).map(l => l.text).join("\n");
      const current = sermonLines[highlightIdx].text;
      const after = sermonLines.slice(highlightIdx + 1, highlightIdx + 4).map(l => l.text).join("\n");
      context.innerHTML = `<pre>${before}\n<span class="highlight">${current}</span>\n${after}</pre>`;
    } else {
      context.innerHTML = "";
    }
  }

  function startRecognition() {
    if (!('webkitSpeechRecognition' in window)) {
      alert("이 브라우저는 음성 인식을 지원하지 않습니다.");
      return;
    }

    const recognition = new webkitSpeechRecognition();
    recognition.lang = "ko-KR";
    recognition.continuous = false;
    recognition.interimResults = false;

    recognition.onresult = function (event) {
      const speechText = event.results[0][0].transcript.trim();
      document.getElementById("speechOutput").textContent = `🎙 인식된 음성: ${speechText}`;
      matchSpeechToSermon(speechText);
    };

    recognition.onerror = function (event) {
      alert("음성 인식 오류: " + event.error);
    };

    recognition.start();
    setTimeout(() => recognition.stop(), 4000);
  }

  function matchSpeechToSermon(speech) {
    let bestMatchIdx = -1;
    let maxScore = 0;

    for (let idx = 0; idx < sermonLines.length; idx++) {
      const line = sermonLines[idx];
      const clean = line.text.replace(/[\[\]]/g, '');
      const score = fuzzySimilarity(speech, clean);

      if (score > maxScore) {
        maxScore = score;
        bestMatchIdx = idx;
      }

      if (score >= 0.9) {
        renderSermon(idx);
        return;
      }
    }

    if (maxScore > 0.5) {
      renderSermon(bestMatchIdx);
    } else {
      alert("일치하는 설교문을 찾을 수 없습니다.\n음성: " + speech);
    }
  }

  // 퍼지 유사도 계산
  function fuzzySimilarity(a, b) {
    const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
    const maxLen = Math.max(a.length, b.length);
    return maxLen === 0 ? 1 : (1 - distance / maxLen);
  }

  function levenshteinDistance(a, b) {
    const matrix = Array.from({ length: a.length + 1 }, () =>
      Array(b.length + 1).fill(0)
    );

    for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
    for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

    for (let i = 1; i <= a.length; i++) {
      for (let j = 1; j <= b.length; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }

    return matrix[a.length][b.length];
  }
</script>
</body>
</html>
