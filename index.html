<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>설교문 음성 하이라이트</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 180px; }
    .highlight { background: yellow; font-weight: bold; }
    .before { background: #f0f0f0; }
    .after { background: #f9f9f9; }
    .block { margin-left: 0; }
    .indent1 { margin-left: 20px; }
    .indent2 { margin-left: 40px; }
    .tree { margin-top: 1em; background: #f5f5f5; padding: 10px; border: 1px solid #ddd; }
    #speechOutput { color: green; font-weight: bold; margin-top: 10px; }
  </style>
</head>
<body>

<h1>설교문 구조 분석 & 음성 인식 하이라이트 0005</h1>

<textarea id="sermonInput" placeholder="설교문을 붙여넣으세요..."></textarea>
<p><button onclick="startRecognitionLoop()">🎤 실시간 음성 감지 시작</button></p>
<p id="speechOutput"></p>

<p>
  문맥 범위 (앞뒤 줄 수):
  <input type="range" id="contextRange" min="1" max="10" value="5" oninput="updateContextLabel(this.value)">
  <span id="contextLabel">5</span>줄
</p>
<p>
  유사도 기준 (0.0 ~ 1.0):
  <input type="range" id="similarityThreshold" min="0.1" max="1" step="0.05" value="0.5" oninput="updateSimilarityLabel(this.value)">
  <span id="similarityLabel">0.50</span>
</p>

<h2>① 현재 설교 구간 (하이라이트 중심)</h2>
<div id="sermonDisplay"></div>

<script>
  let sermonLines = [];
  let currentIdx = 0;
  let isListening = false;

  document.getElementById("sermonInput").addEventListener("input", analyzeSermon);

  function updateContextLabel(val) {
    document.getElementById("contextLabel").textContent = val;
  }

  function updateSimilarityLabel(val) {
    document.getElementById("similarityLabel").textContent = parseFloat(val).toFixed(2);
  }

  function analyzeSermon() {
    const input = document.getElementById("sermonInput").value;
    const lines = input.split(/\n/).filter(l => l.trim() !== "");

    sermonLines = lines.map((line, idx) => {
      let indent = "block";
      if (/^\d+\.\s/.test(line)) indent = "block";
      else if (/^\d+\)\s/.test(line)) indent = "indent1";
      else if (/^\(\d+\)\s/.test(line)) indent = "indent2";
      return { idx, text: line.trim(), indent };
    });

    currentIdx = 0;
    for (let i = 0; i < sermonLines.length; i++) {
      if (sermonLines[i].text.trim().startsWith("[]")) {
        currentIdx = i;
        break;
      }
    }

    renderLimitedSermon();
  }

  function renderLimitedSermon(highlightIdx = -1) {
    const container = document.getElementById("sermonDisplay");
    container.innerHTML = "";

    const contextRange = parseInt(document.getElementById("contextRange").value);
    const start = Math.max(0, highlightIdx - contextRange);
    const end = Math.min(sermonLines.length, highlightIdx + contextRange + 1);

    for (let idx = start; idx < end; idx++) {
      const line = sermonLines[idx];
      const div = document.createElement("div");
      div.className = line.indent;
      if (idx === highlightIdx) {
        div.classList.add("highlight");
        div.style.fontSize = "1.5em";
      } else if (idx < highlightIdx) {
        div.classList.add("before");
      } else {
        div.classList.add("after");
      }
      div.textContent = line.text;
      container.appendChild(div);
    }
  }

  function startRecognitionLoop() {
    if (isListening) return;
    isListening = true;
    recognize();
  }

  function recognize() {
    if (!isListening) return;

    const recognition = new webkitSpeechRecognition();
    recognition.lang = "ko-KR";
    recognition.continuous = false;
    recognition.interimResults = false;

    recognition.onresult = function (event) {
      const speechText = event.results[0][0].transcript.trim();
      document.getElementById("speechOutput").textContent = `🎙 인식된 음성: ${speechText}`;
      const matched = processMatching(speechText);
      setTimeout(() => recognize(), 500);
    };

    recognition.onerror = function (event) {
      console.warn("음성 인식 오류:", event.error);
      setTimeout(() => recognize(), 1000);
    };

    recognition.onend = function () {
      setTimeout(() => recognize(), 500);
    };

    recognition.start();
  }

  function processMatching(speech) {
    let bestMatchIdx = -1;
    let maxScore = 0;
    let count = 0;
    const threshold = parseFloat(document.getElementById("similarityThreshold").value);

    for (let idx = currentIdx + 1; idx < sermonLines.length && count < 6; idx++) {
      if (!sermonLines[idx].text.startsWith("[]")) continue;
      count++;
      const clean = sermonLines[idx].text.slice(2).trim();
      const score = fuzzySimilarity(speech, clean);
      console.log(`[비교] 음성: "${speech}" vs 설교문: "${clean}" → 유사도: ${score.toFixed(2)}`);
      if (score > maxScore) {
        maxScore = score;
        bestMatchIdx = idx;
      }
    }

    if (maxScore > threshold && bestMatchIdx !== -1) {
      currentIdx = bestMatchIdx;
      renderLimitedSermon(bestMatchIdx);
      return true;
    }

    renderLimitedSermon();
    return false;
  }

  function fuzzySimilarity(a, b) {
    const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
    const maxLen = Math.max(a.length, b.length);
    return maxLen === 0 ? 1 : (1 - distance / maxLen);
  }

  function levenshteinDistance(a, b) {
    const matrix = Array.from({ length: a.length + 1 }, () =>
      Array(b.length + 1).fill(0)
    );
    for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
    for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= a.length; i++) {
      for (let j = 1; j <= b.length; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }
    return matrix[a.length][b.length];
  }
</script>
</body>
</html>
