<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>설교문 음성 하이라이트</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 180px; }
    .highlight { background: yellow; font-weight: bold; }
    .before { background: #f0f0f0; }
    .after { background: #f9f9f9; }
    .block, .indent1, .indent2 { cursor: pointer; }
    .tree { margin-top: 1em; background: #f5f5f5; padding: 10px; border: 1px solid #ddd; }
    #speechOutput { color: green; font-weight: bold; margin-top: 10px; }
    #structureTree div:hover { background: #eef; }
    .toggle-content { display: none; margin-left: 20px; }
    .toggle-header::before { content: "▶ "; }
    .expanded.toggle-header::before { content: "▼ "; }
  </style>
</head>
<body>

<h1>설교문 구조 분석 & 음성 인식 하이라이트</h1>

<textarea id="sermonInput" placeholder="설교문을 붙여넣으세요..."></textarea>
<p><button onclick="startRecognitionLoop()">🎤 실시간 음성 감지 시작</button></p>
<p id="speechOutput"></p>

<p>
  문맥 범위 (앞뒤 줄 수):
  <input type="range" id="contextRange" min="1" max="10" value="5" oninput="updateContextLabel(this.value)">
  <span id="contextLabel">5</span>줄
</p>

<h2>② 설교문 구조 (선택 가능)</h2>
<div id="structureTree" class="tree" tabindex="0"></div>

<h2>① 현재 설교 구간 (하이라이트 중심)</h2>
<div id="sermonDisplay"></div>

<script>
  let sermonLines = [];
  let currentIdx = 0;
  let isListening = false;

  document.getElementById("sermonInput").addEventListener("input", analyzeSermon);

  function updateContextLabel(val) {
    document.getElementById("contextLabel").textContent = val;
  }

  function analyzeSermon() {
    const input = document.getElementById("sermonInput").value;
    const lines = input.split(/\n/).filter(l => l.trim() !== "");

    sermonLines = lines.map((line, idx) => {
      let indent = "block";
      if (/^\d+\.\s/.test(line)) indent = "block";
      else if (/^\d+\)\s/.test(line)) indent = "indent1";
      else if (/^\(\d+\)\s/.test(line)) indent = "indent2";
      return { idx, text: line.trim(), indent };
    });

    currentIdx = 0;
    for (let i = 0; i < sermonLines.length; i++) {
      if (sermonLines[i].text.trim().startsWith("[]")) {
        currentIdx = i;
        break;
      }
    }

    renderStructureTree();
    renderLimitedSermon();
  }

  function renderStructureTree() {
    const container = document.getElementById("structureTree");
    container.innerHTML = "";
    let currentParent = null;
    let currentChild = null;

    sermonLines.forEach((line, idx) => {
      const div = document.createElement("div");
      div.textContent = line.text;

      if (line.indent === "block") {
        div.className = "block toggle-header";
        div.onclick = () => {
          div.classList.toggle("expanded");
          const content = div.nextSibling;
          if (content && content.classList.contains("toggle-content")) {
            content.style.display = content.style.display === "none" ? "block" : "none";
          }
        };
        container.appendChild(div);

        currentParent = document.createElement("div");
        currentParent.className = "toggle-content";
        currentParent.style.display = "none";
        container.appendChild(currentParent);

      } else {
        const sub = document.createElement("div");
        sub.textContent = line.text;
        sub.className = line.indent;
        sub.onclick = () => {
          currentIdx = line.idx;
          renderLimitedSermon(line.idx);
        };
        if (currentParent) currentParent.appendChild(sub);
        else container.appendChild(sub);
      }
    });
  }

  function renderLimitedSermon(highlightIdx = -1) {
    const container = document.getElementById("sermonDisplay");
    container.innerHTML = "";

    const contextRange = parseInt(document.getElementById("contextRange").value);
    const start = Math.max(0, highlightIdx - contextRange);
    const end = Math.min(sermonLines.length, highlightIdx + contextRange + 1);

    for (let idx = start; idx < end; idx++) {
      const line = sermonLines[idx];
      const div = document.createElement("div");
      div.className = line.indent;
      if (idx === highlightIdx) {
        div.classList.add("highlight");
        div.style.fontSize = "1.5em";
      } else if (idx < highlightIdx) {
        div.classList.add("before");
      } else {
        div.classList.add("after");
      }
      div.textContent = line.text;
      container.appendChild(div);
    }
  }

  function startRecognitionLoop() {
    if (isListening) return;
    isListening = true;
    recognize();
  }

  function recognize() {
    if (!isListening) return;

    const recognition = new webkitSpeechRecognition();
    recognition.lang = "ko-KR";
    recognition.continuous = false;
    recognition.interimResults = false;

    recognition.onresult = function (event) {
      const speechText = event.results[0][0].transcript.trim();
      document.getElementById("speechOutput").textContent = `🎙 인식된 음성: ${speechText}`;
      const matched = processMatching(speechText);
      setTimeout(() => recognize(), 500);
    };

    recognition.onerror = function (event) {
      console.warn("음성 인식 오류:", event.error);
      setTimeout(() => recognize(), 1000);
    };

    recognition.onend = function () {
      setTimeout(() => recognize(), 500);
    };

    recognition.start();
  }

  function isRoughlyMatched(a, b) {
    const cleanA = a.replace(/\s+/g, "");
    const cleanB = b.replace(/\s+/g, "");
    const minLen = Math.min(cleanA.length, cleanB.length);
    if (minLen === 0) return false;

    const includedLength = cleanA.includes(cleanB) ? cleanB.length : cleanB.includes(cleanA) ? cleanA.length : 0;
    return includedLength / minLen >= 0.5;
  }

  function processMatching(speech) {
    for (let idx = currentIdx + 1, count = 0; idx < sermonLines.length && count < 6; idx++) {
      if (!sermonLines[idx].text.startsWith("[]")) continue;
      count++;
      const clean = sermonLines[idx].text.slice(2).trim();
      if (isRoughlyMatched(speech, clean)) {
        currentIdx = idx;
        renderLimitedSermon(idx);
        return true;
      }
    }
    renderLimitedSermon();
    return false;
  }
</script>
</body>
</html>
